; REPL files are a fast way to test our contracts from the terminal. It's a
; common practice to develop contracts with an associated REPL file. This lets
; you exercise various functions from the contract, and provides other
; developers concrete usage examples.
;
; -----
; NOTE: This file is written with the expectation you have already read through
; the associated smart contract. Concepts like namespaces, keysets, interfaces,
; modules, schemas, tables, constants, functions, and formal verification are
; explained there.
; -----
;
; This REPL file tests the goliath-faucet contract. Along the way, we'll learn
; a number of useful REPL-only functions that you can use when writing your
; own contracts. In the rest of this file, we will:
;
; 1. Initialize the REPL session
; 2. Load the contract and its dependencies
; 3. Formally verify the contract
; 4. Create and fund test accounts
; 5. Set up diagnostics for gas consumption
; 6. Execute code from our contract, test the results, and measure the gas used
;
; You can execute this file from the command line with:
;   $ pact faucet.repl
;
; Alternately, to execute this file and remain in the REPL so you can interact
; with the running program, run:
;   $ pact
;   > (load "faucet.repl")

; --------------------
; 1. Initialize the REPL session
; --------------------

; The REPL environment allows us to execute Pact code and inspect the results.
; We can use it to simulate how our contract will behave once deployed to
; Chainweb. However: we aren't actually using Chainweb. That means there
; technically are no nodes, no transactions, no keysets, no existing contracts,
; and so on. Therefore we must set up our REPL environment so that it includes
; data that our contract would expect to exist.
;
; We'll begin with namespaces. All Pact modules must exist within a namespace on
; Chainweb, except for basic contracts provided by Kadena. There are two
; namespaces available for anyone to use on Chainweb: the 'free' namespace and
; the 'user' namespace. Our contract uses the "free" namespace, so we need to
; make sure it exists in our REPL environment. We can define a namespace using
; (define-namespace):
; https://pact-language.readthedocs.io/en/stable/pact-functions.html#define-namespace
;
; Defining a namespace requires that we provide two keysets. The first keyset is
; a user's keyset, such as the faucet account, and it indicates that the user
; must have signed any transaction that deploys code to the given namespace. The
; second keyset is the namespace admin's keyset, and it indicates that the admin
; must sign the transaction that creates the new namespace.
;
; In practice, you only need to care about any of this if the Kadena team grants
; you a namespace of your own. In the REPL environment we will simply mock
; creating the "free" namespace.

; Let's build the the transaction that will create the "free" namespace. We will
; use a mock namespace admin keyset and a mock keyset that will guard our faucet
; account to create the namespace. Since neither of these keysets exist on
; Chainweb, we need to provide them via the transaction data. We can associate
; with a transaction using (env-data):
; https://pact-language.readthedocs.io/en/stable/pact-functions.html#env-data
(env-data
  { "namespace-keyset": { "keys": [ "namespace-public-key" ], "pred": "keys-all" }
  , "goliath-faucet-keyset": { "keys": [ "goliath-faucet-public-key" ], "pred": "keys-all" }
  })

; One last thing before we execute our new transaction: we are going to wrap
; each logical step in our REPL session in (begin-tx) and (commit-tx). This
; mimics executing a transaction on chain. It also allows us to run a few steps
; and then undo them without committing via the (rollback-tx) function. Once a
; transaction has been committed it cannot be rolled back.
; https://pact-language.readthedocs.io/en/latest/pact-functions.html#begin-tx
; https://pact-language.readthedocs.io/en/latest/pact-functions.html#commit-tx
; https://pact-language.readthedocs.io/en/latest/pact-functions.html#rollback-tx
;
; You might expect that (env-data) would be used within a transaction, since it
; mimics a transaction payload. Alas, this function is run at the top-level and
; applies to every transaction until you set new (env-data). While it breaks the
; mental model of transaction data applying to one transaction, it's convenient.
;
; Let's define our namespace.
(begin-tx)
; Our transaction simply consists of sending the below code to a Chainweb node
; for execution, where (read-keyset) is used to read keysets from the
; transaction data which we assigned with (env-data).
(define-namespace "free" (read-keyset "goliath-faucet-keyset") (read-keyset "namespace-keyset"))
(commit-tx)

; Now that the "free" namespace exists, let's move on to other data that our
; contract expects to exist on-chain.
;
; Our contract uses the (transfer-create) function from the coin-v4 contract.
; That contract implements the fungible-v2 and fungible-xchain-v1 interfaces.
; Our contract therefore expects that all three of these contracts have been
; deployed to Chainweb.
;
; To "deploy" a contract in the repl, use the (load) function:
; https://pact-language.readthedocs.io/en/latest/pact-functions.html#load
;
; The (load) function takes a filepath. For that reason, we've saved copies
; of the fungible-v2, fungible-xchain-v1, and coin-v4 contracts in the 'root'
; directory in our project. This is a convention for storing contracts that are
; external to your project and deployed on Chainweb but which you need access
; to in your tests.
(begin-tx)
(load "./root/fungible-v2.pact")
(load "./root/fungible-xchain-v1.pact")
(load "./root/coin-v4.pact")

; If a contract contains tables, then they need to be created when you deploy
; the contract. You can do that with the (create-table) function. The coin-v4
; contract defines two tables (you can find them by looking for calls to the
; (deftable) function in the contract).
;
; Note: these contracts use the root namespace, which means you must refer to
; them directly by their name with no 'free', 'user', or other prefix.
(create-table coin.coin-table)
(create-table coin.allocation-table)
(commit-tx)

; Done! We've now ensured that all data our contract expects to exist on-chain
; has been loaded into the REPL environment. We can now deploy our own contract
; and begin testing it.

; ----------------------------------------
; 2. Load the contract
; ----------------------------------------

; Before we begin, let's reset the transaction data (after all, when we deploy
; our contract, we won't expect the namespace keyset to be there in the data).
; It's a smart move to reset (env-data) before every new transaction.
;
; Recall that our contract expects to read a keyset from the deployment
; transaction data at the key "goliath-faucet-keyset" so it can register the
; keyset on Chainweb. The initialization step also expects an "upgrade" key that
; tells it whether to create tables or not.
;
; Note: every call to (env-data) completely replaces the previous data.
(env-data
  { "goliath-faucet-keyset": { "keys": [ "goliath-faucet-public-key" ], "pred": "keys-all" }
  , "upgrade": false
  })

; Our contract also includes a safety check that ensures that the keys in the
; keyset that we're registering were also used to sign the deployment
; transaction. We can simulate signing a transaction using the (env-sigs)
; REPL-only function:
; https://pact-language.readthedocs.io/en/latest/pact-functions.html#env-sigs
;
; Below, we indicate that the private key associated with the goliath-faucet
; public key has been used to sign this transaction. The "caps" field is for
; listing capabilities that we would like to scope our signature to; we'll see
; how this is used a little later on.
(env-sigs [{"key": "goliath-faucet-public-key", "caps": []}])

(begin-tx)
(load "./faucet.pact")
(commit-tx)

; Voila! We've now "deployed" our contract and can begin interacting with it.

; ----------------------------------------
; 3. Formally verify the contract
; ----------------------------------------

; Pact provides a powerful formal verification system that can prove that
; invalid states cannot be reached in our contract code. The interface in our
; contract has asserted some models that it would like Pact to verify. We can
; typecheck our code and run formal verification in the REPL with (verify):
; https://pact-language.readthedocs.io/en/latest/pact-properties.html
; https://pact-language.readthedocs.io/en/latest/pact-functions.html#verify
;
; Try disabling some of the (enforce) checks in the Pact module to see how the
; formal verification catches invalid inputs!
(verify "free.goliath-faucet")

; If you are not using any formal verification in your Pact code, but you would
; still like Pact to verify that your types are correct, then you can use the
; (typecheck) function. This isn't necessary in our case, because (verify) will
; also typecheck the module.
; https://pact-language.readthedocs.io/en/latest/pact-functions.html#typecheck

; ----------------------------------------
; 4. Perform test setup by creating and funding accounts
; ----------------------------------------

; With our contract and its dependencies loaded, we can technically begin
; calling our contract API. However, our faucet contract is all about
; transferring funds among accounts, and no accounts yet exist in our test
; environment. With no accounts and no money, our faucet can't do anything.
;
; Let's create and fund some test accounts!
;
; A Kadena account pairs an address (such as "k:12345" or "alice") with a keyset
; (a guard that determines what keys control the account). Before we can create
; our test accounts we need to have a keyset for each one.
;
; We need three accounts for our tests. We need the "bank" account, which will
; fund the faucet. We need the faucet account, which distributes funds to users.
; And we need at least one user account so it can request funds. We've already
; defined the faucet keyset during our contract deployment, but we haven't yet
; defined keysets for the bank and the user accounts.
;
; Let's start by registering those keysets.
(env-data
  { "bank-keyset": { "keys": [ "bank-public-key" ], "pred": "keys-all" }
  , "user-keyset": { "keys": [ "user-public-key" ], "pred": "keys-all" }
  })

(begin-tx)
(define-keyset "bank-keyset" (read-keyset "bank-keyset"))
(define-keyset "user-keyset" (read-keyset "user-keyset"))
(commit-tx)

; As usual, we'll clear the transaction data before moving to the next one.
(env-data {})

; Accounts can be created on Chainweb using the (coin.create-account) function,
; or by transferring funds to the account with (coin.transfer-create). In our
; case we'll create the accounts and fund them afterwards.
(begin-tx)
(coin.create-account "bank" (describe-keyset "bank-keyset"))
(coin.create-account "goliath-faucet" (describe-keyset "goliath-faucet-keyset"))
(coin.create-account "user" (describe-keyset "user-keyset"))

; Next, we need to ensure these accounts have some funds. On Chainweb, you can
; get funds from one of two places: someone transfers you KDA, or you mine the
; KDA yourself. We don't have access to either source of funding in the REPL,
; but we can simulate mining KDA by referring again to the coin contract.
;
; The coin contract includes a (coinbase) function that is used to reward miners
; by minting KDA and distributing it to them when they mine a block. We can't
; call this function on Chainweb because it is protected by the COINBASE
; capability:
; https://github.com/kadena-io/chainweb-node/blob/4dc69750eeffbf6eb2ce901b3d951534cc98e9be/pact/coin-contract/coin.pact#L324
;
; A function protected by a call to (require-capability) cannot be called from
; outside the module, because capabilities can only be granted within the module
; that defined the capability. However, in the REPL environment we have access
; to a special function to magically grant ourselves a capability:
; https://pact-language.readthedocs.io/en/latest/pact-functions.html#test-capability
;
; Let's use it to give ourselves the COINBASE capability.
(test-capability (coin.COINBASE))

; Now that we've been granted the COINBASE capability we can call the (coinbase)
; function. Let's use it to mint KDA and provide it to the bank as if the bank
; mined a block and was rewarded with a hefty sum:
(coin.coinbase "bank" (describe-keyset "bank-keyset") 1000.0)

; Finally, let's verify this worked. We can use the (expect), (expect-that), and
; (expect-failure) functions to make test assertions in our REPL code:
; https://pact-language.readthedocs.io/en/latest/pact-functions.html#expect
; https://pact-language.readthedocs.io/en/latest/pact-functions.html#expect-that
; https://pact-language.readthedocs.io/en/latest/pact-functions.html#expect-failure
;
; The (coin.get-balance) function records how much KDA a particular account
; has, or fails with an error if the account does not exist. We can use it
; to verify we did indeed create the bank account.
(expect "Bank account exists and has 1000.0 KDA"
  1000.0 (coin.get-balance "bank"))
(commit-tx)

; Great! Our bank account now exists and we can use it to fund our faucet. This
; is how our deployment will work, too: we create our faucet account, receive
; funds, and then deploy the contract using the faucet account.
;
; The standard way to send funds on Chainweb is to rely on the (transfer)
; functions from the (coin) contract. If we want to transfer funds and also
; create a new account then we should use the (transfer-create) function:
; https://github.com/kadena-io/chainweb-node/blob/4dc69750eeffbf6eb2ce901b3d951534cc98e9be/pact/coin-contract/coin.pact#L291-L313
;
; Of course, we can't send a transaction to Chainweb attempting to transfer
; from one account to another arbitrarily; you'll notice that the (transfer)
; functions attempt to install the TRANSFER capability. For example:
; https://github.com/kadena-io/chainweb-node/blob/4dc69750eeffbf6eb2ce901b3d951534cc98e9be/pact/coin-contract/coin.pact#L310
;
; The TRANSFER capability is a managed capability. Managed capabilities cannot
; be installed by contract code unless the transaction has been signed and that
; signature has explicitly been scoped to the capability in question. In this
; case, that means that we can only transfer funds from the bank account to the
; faucet account if the bank account has signed the transaction and scoped its
; signature to include the TRANSFER capability.
;
; Below, the bank account keys sign the transaction, and the signature is scoped
; to the TRANSFER capability. The capability takes three arguments to restrict
; how much authorization is being granted: the account to transfer from, the
; account to transfer to, and the maximum amount that can be transferred. If the
; Pact code in the transaction tries to transfer to a different account or tries
; to transfer a larger amount, then the capability will not be granted and the
; transaction will fail.
(env-sigs [{"key": "bank-public-key", "caps": [(coin.TRANSFER "bank" "goliath-faucet" 1000.0)]}])

(begin-tx)
; Now that our transaction has been signed by the bank and the bank has scoped
; its signature to the TRANSFER capability, we can execute the transfer by
; calling the (transfer) function. Below, we execute a transfer from the bank to
; the "goliath-faucet" account.
(coin.transfer "bank" "goliath-faucet" 1000.0)

; Our faucet account should have its KDA!
(expect "Faucet account has 1000.0 KDA"
  1000.0 (coin.get-balance "goliath-faucet"))

; Notably, acquiring the TRANSFER capability for 1000.0 KDA means that the bank
; has only agreed to transfer up to that amount. We can't tell the bank to
; transfer more than it agreed to. This is implemented in the TRANSFER_mgr
; capability manager function that decides whether or not to grant the
; TRANSFER capability:
; https://github.com/kadena-io/chainweb-node/blob/4dc69750eeffbf6eb2ce901b3d951534cc98e9be/pact/coin-contract/coin.pact#L78-L81
(expect-failure "Bank will not transfer more than 1000.0 KDA"
  (coin.transfer "bank" "goliath-faucet" 1.0))
(commit-tx)

; ----------------------------------------
; 5. Set up diagnostics for gas consumption
; ----------------------------------------

; One of the most important concepts when building a dapp on a blockchain like
; Chainweb is gas: computations on chain cost gas, which is paid for using KDA.
; This cost is either paid by users of the dapp or on the user's behalf by the
; dapp itself. Either way, if you create a dapp, you need to be able to estimate
; the cost of running your contracts.
;
; The Pact REPL  provides a handy way to measure gas consumption in a contract
; via the (env-gas*) family of functions.
; https://pact-language.readthedocs.io/en/latest/pact-functions.html#env-gas
;
;   * (env-gasmodel) lets you specify how to store record of gas consumption,
;     which you have to set up before taking any measurements.
;   * (env-gaslog) lets you measure gas consumption over a specific block.
;   * (env-gas) lets you read the current gas count if provided no arguments,
;     and lets you manually set the gas count if provided an integer (such as 0
;     to reset the counter to 0).
;   * (env-gaslimit) lets you set a limit to the units of gas that can be
;     consumed in the REPL session. It will throw an error if exceeded. The
;     maximum gas that can be consumed in a single transaction is 150000. That
;     can be useful limit to set when you want to measure a single .pact file
;     and see how much gas it would cost to execute the entire thing in one
;     transaction on Chainweb.
;
; From this point on, we'll measure the amount of gas consumed by various calls
; to our contract. For context, a "slow" transaction on Chainweb costs about
; 0.01 KDA per million units of gas.
;
; Note that gas consumption depends in part on the size of the Pact code sent
; to Chainweb, whether you are using transaction data for the arguments or
; inlining the arguments into the Pact code, and so on. It's always a good idea
; to treat gas measurements as estimates and round them up by at least 1% when
; submitting requests to Chainweb.
(env-gasmodel "table")
(env-gaslimit 150000)

; ----------------------------------------
; 6. Execute code from our contract, test the results, and measure the gas used
; ----------------------------------------

; We've come a long way. We've set up our pseudo-Chainweb environment. We've
; "deployed" and formally verified our contract. Our test environment is fully
; set up: the bank has funded our faucet, and the faucet is ready to begin
; sending funds. We've even enabled metrics so we can measure how much gas is
; consumed by our contract functions. Let's get started testing our contract!
;
; Here's how our faucet works:
;
;  1. Anyone can ask for KDA from the faucet.
;  2. By default, the faucet will send a maximum of 20 KDA in a single call to
;     (request-funds). This limit can be adjusted with (update-request-limit).
;  3. By default, an address cannot request more than 100 KDA in total. This
;     limit can be adjusted with (update-account-limit).
;
; Our tests should verify this behaviour and serve as an example of how to call
; functions in our contract.

; If all our tests passed, then we can print out a little report:
(print "\nBeginning tests...")

; -----
; TEST 1
; -----
(print "Test 1: Anyone can ask for KDA from the faucet.")

; Let's build our first transaction. To request funds from the faucet, we must
; sign the transaction with the faucet account's keys, and that signature must
; be scoped to the TRANSFER capability:
(env-sigs [{"key": "goliath-faucet-public-key", "caps": [(coin.TRANSFER "goliath-faucet" "user" 20.0)]}])

; Now, let's represent someone with a Goliath wallet requesting KDA. The user
; received a new key pair when they signed up, which we already included in the
; call to (env-data) earlier. Next, the user clicks "Request KDA" in the UI
; and tells the faucet to send them a certain amount of KDA. The UI broadcasts
; a transaction to the blockchain that grants the TRANSFER capability and asks
; the goliath-faucet contract to transfer those funds to the specified user.
;
; Let's simulate what happens when the user clicks "Request KDA" for varying
; amounts. First, let's have the user request 20.0 KDA.
(begin-tx)
(env-gaslog)
(free.goliath-faucet.request-funds "user" (describe-keyset "user-keyset") 20.0)
(env-gaslog)
; We can measusure how much gas a call to request-funds takes using (env-gaslog)
(let (( expected-gas 791 ))
  (expect (format "Requesting funds costs {} gas" [expected-gas]) expected-gas (env-gas)))
(expect "User account has been created and has 20 KDA."
  20.0 (coin.get-balance "user"))
(expect "Faucet has spent 20 KDA and has 980 KDA remaining."
  980.0 (coin.get-balance "goliath-faucet"))
(commit-tx)

; -----
; TEST 2
; -----
(print "Test 2: By default you can request up to 20 KDA per call to (request-funds).")

; What if we had a bug in the UI and accidentally let them request more than the
; maximum 20 KDA per transaction?
(env-sigs [{"key": "goliath-faucet-public-key", "caps": [(coin.TRANSFER "goliath-faucet" "user" 25.0)]}])

(begin-tx)
(expect-failure (format "Cannot send more than {} per request" [free.goliath-faucet-interface.REQUEST_LIMIT_MIN])
  (free.goliath-faucet.request-funds "user" (describe-keyset "user-keyset") 25.0))
(commit-tx)

; -----
; TEST 3
; -----
(print "Test 3: By default you can request up to 100 KDA per address.")

; Great! The contract rejected the transaction. Let's have the user keep
; requesting KDA and see if they can request past the maximum 100 KDA limit.
;
; We'll grant a large TRANSFER capability so that we don't have to break this
; across multiple transactions. Our single transaction will make many calls to
; (request-funds) in a row.
(env-sigs [{"key": "goliath-faucet-public-key", "caps": [(coin.TRANSFER "goliath-faucet" "user" 100.0)]}])

(begin-tx)
(free.goliath-faucet.request-funds "user" (describe-keyset "user-keyset") 20.0)
(free.goliath-faucet.request-funds "user" (describe-keyset "user-keyset") 20.0)
(free.goliath-faucet.request-funds "user" (describe-keyset "user-keyset") 20.0)
(free.goliath-faucet.request-funds "user" (describe-keyset "user-keyset") 20.0)

; At this point, the user has received the full 100.0 KDA they're allowed. The
; next request should fail.
(expect-failure (format "exceeds the maximum per account ({} KDA)" [free.goliath-faucet-interface.ACCOUNT_LIMIT_MIN])
  (free.goliath-faucet.request-funds "user" (describe-keyset "user-keyset") 20.0))
(commit-tx)

; -----
; TEST 4
; -----
(print "Test 4: The faucet account can adjust the per-account limit.")

; First, let's try signing this transaction as someone other than the faucet
; account. Adjusting the limit should fail with a keyset error.
(env-sigs [])
(begin-tx)
(expect-failure "Keyset failure (keys-all): 'goliath-faucet-keyset"
  (free.goliath-faucet.update-account-limit 200.0))
(commit-tx)

; Now let's try setting the per-account limit! This should succeed so long as we
; stay within the valid range.
(env-sigs [{"key": "goliath-faucet-public-key", "caps": [(coin.TRANSFER "goliath-faucet" "user" 100.0), (coin.GAS)]}])
(begin-tx)
(expect-failure (format "{} is not within the range of valid per-account limits (100.0 to 1000.0 KDA)" [ 50.0 ])
  (free.goliath-faucet.update-account-limit 50.0))
(expect-failure (format "{} is not within the range of valid per-account limits (100.0 to 1000.0 KDA)" [ 5000.0 ])
  (free.goliath-faucet.update-account-limit 5000.0))

; This is within the limits, so it should succeed.
(free.goliath-faucet.update-account-limit 200.0)

;  ; Now we should be able to transfer more funds to our target account.
;  (free.goliath-faucet.request-funds "user" (describe-keyset "user-keyset") 10.0)
(commit-tx)

; -----
; TEST 5
; -----
(print "Test 5: The faucet account can adjust the per-request limit.")

; If all our tests passed, then we can print out a little report:
(print "\nTests passed!\n-----")
(print (format "User balance after transfers: {}" [(coin.get-balance "user")]))
(print (format "Faucet balance after transfers: {}" [(coin.get-balance "goliath-faucet")]))
